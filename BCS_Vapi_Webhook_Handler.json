{
  "name": "BCS Vapi Webhook Handler",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vapi-handler",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-001",
      "name": "Webhook - Vapi End-of-Call",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 320],
      "webhookId": "vapi-handler"
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {}
      },
      "id": "respond-001",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [240, 320]
    },
    {
      "parameters": {
        "jsCode": "// Verify Webhook Signature\n// Based on WORKFLOW_ADAPTATION_PLAN.md Section 4.2 with FIX #2 applied\n\nconst crypto = require('crypto');\n\n// FIX #2: Header name is 'X-Vapi-Signature' (capital X) - verified from Vapi docs\nconst signature = $input.item.headers['X-Vapi-Signature'] || $input.item.headers['x-vapi-signature'];\nconst secret = $vars.VAPI_WEBHOOK_SECRET;\nconst payload = JSON.stringify($input.item.body);\n\nif (!signature) {\n  throw new Error('Missing webhook signature');\n}\n\nconst expectedSignature = crypto\n  .createHmac('sha256', secret)\n  .update(payload)\n  .digest('hex');\n\nif (signature !== expectedSignature) {\n  throw new Error('Invalid webhook signature');\n}\n\nreturn $input.item.json;"
      },
      "id": "code-verify-001",
      "name": "Verify Signature",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [480, 320]
    },
    {
      "parameters": {
        "jsCode": "// Parse Call Data from Webhook\n// Based on WORKFLOW_ADAPTATION_PLAN.md Section 4.3 with FIX #2 and #7 applied\n\n// FIX #2: Updated webhook payload parsing based on Vapi docs verification\nconst webhook = $input.item.json;\nconst message = webhook.message;\n\n// Verify this is an end-of-call-report event\nif (message.type !== 'end-of-call-report') {\n  throw new Error(`Unexpected webhook type: ${message.type}`);\n}\n\nconst call = message.call;\nconst artifact = message.artifact || {};\nconst endedReason = message.endedReason;\n\n// Extract debtor_id from assistant overrides (stored in call object)\nconst debtorId = call.assistantOverrides?.variableValues?.debtor_id;\n\nif (!debtorId) {\n  throw new Error('Missing debtor_id in webhook');\n}\n\n// Check if call succeeded or failed\nconst callStatus = call.status; // \"ended\" or \"failed\"\n\n// Parse function call (log_outcome)\n// NOTE: Vapi may send this in artifact.messages array - needs testing\nlet outcome = 'UNKNOWN';\nlet paymentMethod = 'none';\nlet notes = '';\nlet promisedDate = null;\n\nif (callStatus === 'failed') {\n  // FIX #7: CALL_FAILED not in function enum - handle separately\n  outcome = 'CALL_FAILED';\n  notes = `Call failed: ${endedReason}`;\n} else if (artifact.messages && artifact.messages.length > 0) {\n  // Search for log_outcome function call in messages\n  // Function calls may appear as toolCalls in message objects\n  let functionCallFound = false;\n\n  for (const msg of artifact.messages) {\n    if (msg.toolCalls && Array.isArray(msg.toolCalls)) {\n      for (const toolCall of msg.toolCalls) {\n        if (toolCall.function?.name === 'log_outcome') {\n          // Parse function arguments (may be string or object)\n          const args = typeof toolCall.function.arguments === 'string'\n            ? JSON.parse(toolCall.function.arguments)\n            : toolCall.function.arguments;\n\n          outcome = args.outcome || 'UNKNOWN';\n          paymentMethod = args.payment_method || 'none';\n          notes = args.notes || '';\n          promisedDate = args.promised_date || null;\n          functionCallFound = true;\n          break;\n        }\n      }\n      if (functionCallFound) break;\n    }\n  }\n\n  if (!functionCallFound) {\n    // No function call found = likely no answer, voicemail, or system error\n    outcome = 'NO_ANSWER';\n    notes = 'No outcome logged by assistant (check transcript)';\n  }\n} else {\n  // No messages in artifact\n  outcome = 'NO_ANSWER';\n  notes = 'No conversation recorded';\n}\n\nreturn {\n  debtor_id: debtorId,\n  call_id: call.id,\n  call_status: callStatus,\n  recording_url: artifact.recording?.url || call.recordingUrl || '',\n  transcript: artifact.transcript || '',\n  outcome: outcome,\n  payment_method: paymentMethod,\n  notes: notes,\n  promised_date: promisedDate,\n  call_duration: call.endedAt && call.startedAt\n    ? (new Date(call.endedAt) - new Date(call.startedAt)) / 1000\n    : 0\n};"
      },
      "id": "code-parse-001",
      "name": "Parse Call Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 320]
    },
    {
      "parameters": {
        "jsCode": "// Calculate Next Action based on Outcome\n// Based on WORKFLOW_ADAPTATION_PLAN.md Section 4.4\n\nconst data = $input.item.json;\nconst outcome = data.outcome;\nconst promisedDate = data.promised_date;\nconst now = new Date();\n\nlet nextAction = null;\nlet nextCallDate = null;\nlet assignedToAi = true;\nlet paymentStatus = 'unpaid';\nlet doNotCall = false;\n\nfunction addDays(date, days) {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n}\n\nfunction addHours(date, hours) {\n  const result = new Date(date);\n  result.setHours(result.getHours() + hours);\n  return result;\n}\n\nswitch(outcome) {\n  case 'PROMISE_TO_PAY':\n    nextAction = 'SCHEDULE_CALL';\n    if (promisedDate) {\n      // Follow up day after promised date\n      nextCallDate = addDays(new Date(promisedDate), 1);\n    } else {\n      // Default: follow up in 7 days\n      nextCallDate = addDays(now, 7);\n    }\n    break;\n\n  case 'READY_TO_PAY':\n    nextAction = 'AWAIT_PAYMENT';\n    // Payment instructions provided verbally during call\n    // Schedule follow-up in 3 days to confirm payment received\n    nextCallDate = addDays(now, 3);\n    assignedToAi = false;\n    break;\n\n  case 'NO_ANSWER':\n  case 'VOICEMAIL':\n    nextAction = 'SCHEDULE_CALL';\n    nextCallDate = addHours(now, 4); // Retry in 4 hours\n    break;\n\n  case 'WRONG_NUMBER':\n    nextAction = 'MANUAL_REVIEW';\n    assignedToAi = false;\n    break;\n\n  case 'DISPUTE_RAISED':\n  case 'HARDSHIP_CLAIMED':\n    nextAction = 'MANUAL_REVIEW';\n    assignedToAi = false;\n    break;\n\n  case 'REFUSED_TO_ENGAGE':\n    nextAction = 'SCHEDULE_CALL';\n    nextCallDate = addDays(now, 7); // Wait 1 week\n    break;\n\n  case 'REQUESTED_NO_CONTACT':\n    nextAction = 'MANUAL_REVIEW';\n    assignedToAi = false;\n    doNotCall = true;\n    break;\n\n  case 'ALREADY_PAID':\n    paymentStatus = 'paid';\n    nextAction = 'CLOSE_ACCOUNT';\n    assignedToAi = false;\n    break;\n\n  case 'CALL_FAILED':\n    nextAction = 'SCHEDULE_CALL';\n    nextCallDate = addHours(now, 2); // Retry in 2 hours\n    break;\n\n  case 'OBJECTED_TO_RECORDING':\n    nextAction = 'MANUAL_REVIEW';\n    assignedToAi = false;\n    break;\n\n  default:\n    nextAction = 'MANUAL_REVIEW';\n    assignedToAi = false;\n}\n\nreturn {\n  ...data,\n  next_action: nextAction,\n  next_call_date: nextCallDate ? nextCallDate.toISOString() : '',\n  assigned_to_ai: assignedToAi,\n  payment_status: paymentStatus,\n  do_not_call: doNotCall\n};"
      },
      "id": "code-calc-001",
      "name": "Calculate Next Action",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [960, 320]
    },
    {
      "parameters": {
        "operation": "lookup",
        "sheetId": "={{ $vars.GOOGLE_SHEETS_SPREADSHEET_ID }}",
        "lookupColumn": "debtor_id",
        "lookupValue": "={{ $json.debtor_id }}",
        "options": {}
      },
      "id": "sheets-lookup-001",
      "name": "Lookup Debtor Row",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 3,
      "position": [1200, 320]
    },
    {
      "parameters": {
        "jsCode": "// Prepare Update Data\n// Based on WORKFLOW_ADAPTATION_PLAN.md Section 4.6\n\nconst parsed = $node['Calculate Next Action'].json;\nconst currentRow = $node['Lookup Debtor Row'].json;\n\nconst currentAttempt = parseInt(currentRow.attempt_number) || 1;\nconst newAttempt = currentAttempt + 1;\n\nconst timestamp = new Date().toLocaleString('en-AU', { timeZone: 'Australia/Sydney' });\nconst newNotes = `${currentRow.notes || ''}\\n[${timestamp}] Attempt ${currentAttempt}: ${parsed.outcome} - ${parsed.notes}`.trim();\n\nreturn {\n  row_number: currentRow.__rowNum__, // n8n provides this\n  call_status: 'completed',\n  call_id: parsed.call_id,\n  recording_url: parsed.recording_url,\n  last_call_date: new Date().toISOString(),\n  last_outcome: parsed.outcome,\n  next_action: parsed.next_action,\n  next_call_date: parsed.next_call_date,\n  attempt_number: newAttempt,\n  notes: newNotes,\n  assigned_to_ai: parsed.assigned_to_ai,\n  payment_status: parsed.payment_status,\n  do_not_call: parsed.do_not_call,\n  payment_method: parsed.payment_method,\n  debtor_id: parsed.debtor_id\n};"
      },
      "id": "code-prep-001",
      "name": "Prepare Update Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 320]
    },
    {
      "parameters": {
        "operation": "update",
        "sheetId": "={{ $vars.GOOGLE_SHEETS_SPREADSHEET_ID }}",
        "range": "Sheet1!M{{ $json.row_number }}:X{{ $json.row_number }}",
        "options": {},
        "valueInputMode": "RAW",
        "dataProperty": "={{ [[$json.call_status, $json.call_id, $json.last_call_date, $json.last_outcome, $json.next_action, $json.next_call_date, $json.attempt_number, $json.notes, $json.assigned_to_ai, $json.payment_status, $json.do_not_call, $json.recording_url]] }}"
      },
      "id": "sheets-update-002",
      "name": "Update Debtor Row",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 3,
      "position": [1680, 320]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-003",
              "leftValue": "={{ $node['Calculate Next Action'].json.next_action }}",
              "rightValue": "MANUAL_REVIEW",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-review-001",
      "name": "IF - Manual Review Needed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1920, 320]
    },
    {
      "parameters": {
        "fromEmail": "={{ $vars.BCS_EMAIL }}",
        "toEmail": "={{ $vars.BCS_EMAIL }}",
        "subject": "BCS Debt Collection - Manual Review Required",
        "message": "=Manual review required for debtor:\\n\\nDebtor ID: {{ $node['Prepare Update Data'].json.debtor_id }}\\nOutcome: {{ $node['Prepare Update Data'].json.last_outcome }}\\nNotes: {{ $node['Prepare Update Data'].json.notes }}\\n\\nView in Google Sheets: https://docs.google.com/spreadsheets/d/{{ $vars.GOOGLE_SHEETS_SPREADSHEET_ID }}/edit",
        "options": {}
      },
      "id": "email-001",
      "name": "Email Peter",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "position": [2160, 480]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Vapi End-of-Call": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          },
          {
            "node": "Verify Signature",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Signature": {
      "main": [
        [
          {
            "node": "Parse Call Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Call Data": {
      "main": [
        [
          {
            "node": "Calculate Next Action",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Next Action": {
      "main": [
        [
          {
            "node": "Lookup Debtor Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lookup Debtor Row": {
      "main": [
        [
          {
            "node": "Prepare Update Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Update Data": {
      "main": [
        [
          {
            "node": "Update Debtor Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Debtor Row": {
      "main": [
        [
          {
            "node": "IF - Manual Review Needed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF - Manual Review Needed?": {
      "main": [
        [
          {
            "node": "Email Peter",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "bcs-vapi-webhook-handler-v1",
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "bcs-debt-collection-bot"
  },
  "id": "BCS_Vapi_Webhook_Handler",
  "tags": ["BCS", "Debt Collection", "Vapi", "Webhook"]
}
